# 系统移植

## uboot

### 1. 什么是uboot

bootloder：boot+loader。是一个用于硬件初始化，引导操作系统启动的小代码

作用：

1. 初始化硬件电路（boot）

2. 引导操作系统（loader）
2. 用于给开发工程师配置机器

（通常是在倒计时到零之前按下任意键进入）

u-boot：是比较通用的一种bootloader





### 2. uboot源码包

#### 2.1 源码包获取

源码下载地址：

[Index of /pub/u-boot/](https://ftp.denx.de/pub/u-boot/)

如何选择源码版本?

1. 有或者接近对应芯片（6818）平台的代码
2. 有支持Linux系统平台的代码

通常选择芯片开发年份一年到两年后的代码

如6818是2015年左右开发的芯片，所以杨工选择了2016.03版本的uboot代码

#### 2.2 源码包目录

arch:架构（x86/arm/mips/ppc/sh)跟处理器底层相关

borad：板级相关外设代码，是厂家推出型号来收集

cmd：uboot交互界面架构代码

common：公共代码或者命令源码

driver：跟外设接口有关，是移植的主要模块，包括几乎所有接口设备的驱动代码

net：网络通信协议相关的内容

lib：提供通用型库文件

include：提供通用的用于声明的头文件

fs：提供用于操作文件系统的方法及各种型号文件系统的驱动

scripts：定义一些用于实现工程包管理的约定协议



#### 2.3 uboot编译过程

编译已经配置好的u-boot源码包（三星版本）

##### a. 工具链准备

先将arm-eabi-4.8.tar.bz2拷至/usr/local/arm/
解压在当前目录: tar xvfj arm-eabi-4.8.tar.bz2 

##### b. 准备工程

#mkdir /opt/mkplat 
#mkdir /opt/mkplat/build_uboot
#cd /opt/mkplat/build_uboot
将u-boot-2014.07_cfg.tar.gz拷至本目录

##### c. 配置编译

#tar xvfz u-boot-2014.07_cfg.tar.gz
解压之后可以看到以下文件:
u-boot-2014.07_cfg

u-boot-2014.07_cfg就是我们要编译的包

#cd u-boot-2014.07_cfg

//清除编译文件
make distclean CROSS_COMPILE=/usr/local/arm/arm-eabi-4.8/bin/arm-eabi-

//配置
make x6818_config CROSS_COMPILE=/usr/local/arm/arm-eabi-4.8/bin/arm-eabi-

//编译
make -j3 CROSS_COMPILE=/usr/local/arm/arm-eabi-4.8/bin/arm-eabi-
经过上面操作之后，会发现在当前的目录下多了一个

ubootpak.bin，这个就是要烧写到开发板的bootloader

##### d. 下载烧写到开发板测试

fastboot flash ubootpak ubootpak.bin

fastboot flash boot boot.img

fastboot flash system qt-rootfs.img

##### e. 再次修改源码

​	#vi include/configs/x6818.h 

将"CONFIG_SYS_PROMPT" 改成自己定义的关键字，保存退出。

再次编译并且烧写到开发板，重启，观察有何改变。（uboot界面的用户名发生对应改变）

#### 2.4 uboot配置编译分析

芯片公司在开发芯片是，同步会开发其uboot源码包，里面包含一些基础支持功能的移植

用户向芯片公司购买芯片并使用时会获取这个包，但是该包会包含大部分不需要的代码。故在真正编译之前，要配置（找出我们需要的代码，剔除不需要的部分），再编译。

如何进行配置？如何通过配置，在众多平台、众多代码中找到我们所需要的代码？

##### 1. 配置过程

###### 第一步：通过makefile来启动脚本

执行配置命令时：

make x6818_config CROSS_COMPILE=/usr/local/arm/arm-eabi-4.8/bin/arm-eabi-

其中的make x6818_config起关键作用，“操作目标 依赖目标（文件）”。这里做了一个make操作，所以要具体到该目录下的makefile文件中去寻找答案

1）实际上执行：

在makefile中有这样的代码：

```makefile
%_config:: outputmakefile
	@$(MKCONFIG) -A $(@:_config=)
	
#而其中的MKCONFIG如下所示
MKCONFIG	:= $(srctree)/mkconfig

#故@$(MKCONFIG) -A $(@:_config=)
#被翻译成./mkconfig -A x6818

```

2） 实质上执行一个shell脚本（自动执行功能）

./mkconfig -A x6818

###### 第二步：通过mkconfig脚本来实现源码的筛选

在脚本执行中：./mkconfig -A x6818，传入了两个参数-A和x6818，在这里分别是$1和$2

而在mkconfig的shell代码中，完成了以下操作：

1）获取开发板信息并初始化给变量

```makefile
if [ \( $# -eq 2 \) -a \( "$1" = "-A" \) ] ; then
	# Automatic mode
	line=`awk '($0 !~ /^#/ && $7 ~ /^'"$2"'$/) { print $1, $2, $3, $4, $5, $6, $7, $8 }' $srctree/boards.cfg`
	if [ -z "$line" ] ; then
		echo "make: *** No rule to make target \`$2_config'.  Stop." >&2
		exit 1
	fi

	set ${line}
	# add default board name if needed
	[ $# = 3 ] && set ${line} ${1}
fi
```

根据给到的x6818参数，代码找到boards.cfg中的参数，并将它们初始化到变量中

| Status | Status | CPU:SPLCPU | SoC     | Vendor  | Board name | Target | Options |
| ------ | ------ | ---------- | ------- | ------- | ---------- | ------ | ------- |
| Active | arm    | slsiap     | s5p6818 | s5p6818 | x6818      | x6818  | -       |
| $1     | $2     | $3         | $4      | $5      | $6         | $7     | $8      |

2)将获取到的参数赋值给具体的变量

arch="arm"
cpu="slsiap"
board="x6818"
vendor="s5p6818"
soc="s5p6818"
3）创建链接指向平台的代码

cd arch/${arch}/include --> cd arch/arm/include

rm -f asm/arch 

```makefile
if [ "${soc}" ] ; then
	ln -s ${LNPREFIX}arch-${soc} asm/arch
elif [ "${cpu}" ] ; then
	ln -s ${LNPREFIX}arch-${cpu} asm/arch
fi

#翻译上述代码如下
#if [ "s5p6818" ] ; then
#	ln -s arch-s5p6818 asm/arch
#elif [ "slsiap" ] ; then
#	ln -s arch-slsiap asm/arch
#fi
```

##### 2. 编译过程

执行配置命令时：

make -j3 CROSS_COMPILE=/usr/local/arm/arm-eabi-4.8/bin/arm-eabi-

这里仅仅是用了make （-j3是使用三个线程的意思）

###### 从打印信息推理：

```
xx1/xx.o
xx1/xxx.o
xx1/built-in.o

xx2/xx.o
xx2/xxx.o
xx2/built-in.o

uboot <- xx1/built-in.o xx2/built-in.o ......

uboot.bin <- uboot

./tools/mk6818 ubootpak.bin nsih.txt 2ndboot u-boot.bin

```

也就是在这个过程中，各级子目录下的xx.c通过 预处理 -> 编译 -> 汇编 成xx.o | 各级xx.o xxx.o等进行小链接成build-in.o | 各个build-in.o再组合进行大的链接成为uboot.elf(uboot) | uboot再转换成为uboot.bin | 最后合并成为最终的ubootpak.bin

###### 实际编译过程：

1. 定义环境变量

   ```makefile
   srctree		:= $(if $(KBUILD_SRC),$(KBUILD_SRC),$(CURDIR))
   objtree		:= $(CURDIR)
   src		:= $(srctree)
   obj		:= $(objtree)
   ```

2. 定义编译工具

   ```makefile
   CC		= $(CROSS_COMPILE)gcc
   CPP		= $(CC) -E
   AR		= $(CROSS_COMPILE)ar
   NM		= $(CROSS_COMPILE)nm
   LDR		= $(CROSS_COMPILE)ldr
   STRIP		= $(CROSS_COMPILE)strip
   OBJCOPY		= $(CROSS_COMPILE)objcopy
   OBJDUMP		= $(CROSS_COMPILE)objdump
   AWK		= awk
   PERL		= perl
   DTC		= dtc
   CHECK		= sparse
   ```

3. 定义源码目录

   ```makefile
   head-y := $(CPUDIR)/start.o
   head-$(CONFIG_4xx) += arch/powerpc/cpu/ppc4xx/resetvec.o
   head-$(CONFIG_MPC85xx) += arch/powerpc/cpu/mpc85xx/resetvec.o
   
   HAVE_VENDOR_COMMON_LIB = $(if $(wildcard $(srctree)/board/$(VENDOR)/common/Makefile),y,n)
   
   libs-y += lib/
   libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
   #...
   ```

4. 找到第一个目标

   ```makefile
   all:
   #...
   #找到第一个目标u-boot.bin，其依赖于u-boot
   u-boot.bin: u-boot FORCE
   	$(call if_changed,objcopy)
   	$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
   	$(BOARD_SIZE_CHECK)
   	./tools/mk6818 ubootpak.bin nsih.txt 2ndboot u-boot.bin
   #...
   #找到第二个目标u-boot，其依赖于u-boot-init与u-boot-main
   u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds
   	$(call if_changed,u-boot__)
   ifeq ($(CONFIG_KALLSYMS),y)
   	smap=`$(call SYSTEM_MAP,u-boot) | \
   		awk '$$2 ~ /[tTwW]/ {printf $$1 $$3 "\\\\000"}'` ; \
   	$(CC) $(c_flags) -DSYSTEM_MAP="\"$${smap}\"" \
   		-c $(srctree)/common/system_map.c -o common/system_map.o
   	$(call cmd,u-boot__) common/system_map.o
   endif
   #...
   #进一步找u-boot-init与u-boot-main
   u-boot-init := $(head-y)
   u-boot-main := $(libs-y)
   #...
   #进一步找head-y与libs-y
   head-y := $(CPUDIR)/start.o
   libs-y += lib/
   #...
   libs-y		:= $(patsubst %/, %/built-in.o, $(libs-y))
   #这里的libs-y就包含了各级子目录下的built-in.o
   ```

所以从代码来看，编译的过程和我们猜想的一样，是一级级向上的。

#### 3. uboot源码包分析

论证：uboot的启动过程是什么样子的？

1. 进行简单硬件初始化
2. 可以进入交互界面实现命令调用
3. 可以引导启动kernel启动

要阅读的源码：

arch/arm/cpu/slsiap/s5p6818/start.s	//这是整个程序的第一个文件

在u-boot.lds文件中：

​	OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
​	OUTPUT_ARCH(arm)
​	ENTRY(_stext)		这里表明整个程序中的第一个进口是"stext"

由此可知道：uboot的入口是在start.s文件中的_stext这个地方



启动过程追踪：

##### 第一阶段：执行一段汇编程序

```assembly
_stext:
	b 	reset
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq

reset:
	/*保存启动参数*/
	bl	save_boot_params
	/*
	 * set the cpu to SVC32 mode（管理模式）
	 */
	mrs	r0, cpsr
	bic	r0, r0, #0x1f
	orr	r0, r0, #0xd3
	msr	cpsr,r0

	/* disable watchdog */
	/* 
	 * 看门狗启动后会有一个定时器启动
	 * 当计数值归零前没有喂狗会使得
	 * 系统自动重启
	 */
	ldr	r0, =0xC0019000
	mov	r1, #0
	str	r1, [r0]
	
	/* 关闭cache/MMU */
	bl	cpu_init_cp15
	bl	cpu_init_crit

#ifdef CONFIG_RELOC_TO_TEXT_BASE
/*
	* 如果用NOR flash启动，判断出来后就会执行重定位代码到DDR3中，
	* 如果是NAND flash，则不会执行以下两个部分
	*/
relocate_to_text:
	/*
	 * relocate u-boot code on memory to text base
	 * for nexell arm core (add by jhkim)
	 */
	adr	r0, _stext				/* r0 <- current position of code   */
	ldr	r1, TEXT_BASE			/* test if we run from flash or RAM */
	cmp r0, r1              	/* don't reloc during debug         */
	beq clear_bss

	ldr	r2, _bss_start_ofs
	add	r2, r0, r2				/* r2 <- source end address         */

copy_loop_text:
	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
	cmp	r0, r2					/* until source end addreee [r2]    */
	ble	copy_loop_text

	ldr	r1, TEXT_BASE			/* restart at text base */
	mov pc, r1


```

###### 为什么需要重定位代码部分？

重定位代码部分实现的功能：

判断代码是否是在NOR flash中跑，如果是，就将代码拷贝出来到内存中跑

NOR flash可以在其中直接跑代码，但是其空间较小，且跑的相对DDR3来说也比较慢

为什么要有这样一段代码？为什么要烧到NOR flash中跑？

像手上的这块6818，内部是有内置irom里面有bl0的代码，保证一上电后6818就能跑起来，将mmc（NAND flash）中的uboot代码迁移到内存中来跑。

但有的芯片它是没有内置irom的，其只能将NOR flash中uboot的代码放在0x00的地址上，一上电就去执行NOR flash的代码。但它跑起来的时候速度比较慢，于是乎就判断自己在哪里跑，如果还在NOR flash中跑的话，就将代码迁移出去，再跳过去继续跑。

```assembly

/* 将bss段初始化为空 */
clear_bss:
#ifdef CONFIG_MMU_ENABLE
	bl	mmu_turn_on
#endif
	ldr	r0, _bss_start_ofs
	ldr	r1, _bss_end_ofs
	ldr	r4, TEXT_BASE			/* text addr */
	add	r0, r0, r4
	add	r1, r1, r4
	mov	r2, #0x00000000			/* clear */
clbss_l:str	r2, [r0]			/* clear loop... */
	add	r0, r0, #4
	cmp	r0, r1
	bne	clbss_l

	/* ... */
	bl	board_init_f
	
	/* ... */
	ldr	pc, =board_init_r	
    /* 跳到board_init_r地址上运行 */
	/* this is auto-relocated! */

```

board_init_f 函数中的关键代码：
	if (initcall_run_list(init_sequence_f))
		hang();
作用主要是对硬件完成简单初始化。

这里用了一个很巧妙的数据结构。init_sequence_f是一个指针函数数组，里面指向了各个硬件初始化函数。这样在初始化的时候就可以在代码中快速地调用初始化函数。

board_init_r 函数中主要是对uboot内部的各种子系统进行初始化（中断管理子系统、定时器、网络等）：

​	initr_caches； board_init； initr_mem； ...... ;run_main_loop;

##### 第二阶段：执行c程序

run_main_loop:

​	for (;;)
​		main_loop();

main_loop函数主要实现的是uboot交互界面（实现命令交互）

1. 正常进入uboot的交互界面

2. 如果定义初始化bootcmd内容并且boordelay定义为大于0，就不会直接进入交互界面，而是会出现delay提示界面：

   ​	在规定时间内没有按下回车（触发信号），就去引导内核启动

   ​	在规定时间内按下回车（触发信号），就会执行bootcmd中的命令并进入uboot的交互界面

###### uboot实操情况

在uboot界面可以看到，当输入命令printenv时，能够看到环境参数

```
bootargs=lcd=vs070cxn tp=gslx680-linux root=/dev/mmcblk0p2 rw rootfstype=ext4
bootcmd=ext4load mmc 2:1 0x48000000 uImage;bootm 0x48000000
```

1. **ext4load mmc 2:1 0x48000000 uImage**

   `ext4load`: 这是一个U-Boot命令，用于从ext4文件系统加载文件

​	`mmc 2:1`: 指定从MMC（多媒体卡）设备的第二个设备的第一个分区加载文件

​	`0x48000000`: 指定将文件加载到内存中的这个地址

​	`uImage`: 这是要加载的文件名，通常是Linux内核映像

2. **bootm 0x48000000**:

​	`bootm`: 启动映像命令。

​	`0x48000000`: 指定从这个内存地址启动映像。

在setenv时，“；”前面需要加一个斜杠

###### mainloop核心代码分析

s = bootdelay_process();
	if (cli_process_fdt(&s))
		cli_secure_boot_cmd(s);

​	autoboot_command(s);

​	cli_loop();

bootdelay_process：

```c
const char *bootdelay_process(void)
{
	char *s;
	int bootdelay;
	
	s = getenv("bootdelay");
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY; //判断s是否为空，并转换为整型返回到bootdelay中
	
#if defined(CONFIG_MENU_SHOW)
	bootdelay = menu_show(bootdelay);
#endif
	bootretry_init_cmd_timeout();
	
	s = getenv("bootcmd");

	process_fdt_options(gd->fdt_blob);
	stored_bootdelay = bootdelay;

	return s;
}
```

也就是读取bootdelay，并显示到界面（若定义了CONFIG_MENU_SHOW）。再拿到bootcmd并将bootcmd内容返回来，将bootdelay存储在全局变量stored_bootdelay中。

autoboot_command(s):

```c
void autoboot_command(const char *s)
{
	if (stored_bootdelay != -1 && s && !abortboot(stored_bootdelay)) {

		run_command_list(s, -1, 0);
	}
}
```

如果有bootcmd，并且bootdelay大于0，同时规定时间内没有按下回车,就执行启动命令

cli_loop()：停在交互界面

#### 4. logo显示移植

##### 任务

修改u-boot-2014.07_cfg.tar.bz2中的代码，实现可以显示用户自定义的图片

##### 定位源码

找到 lcd.c 代码查看，在其中可以看到很多和lcd显示相关的函数。

其中能够看到一个函数为lcd_init，层层向上查询可以找到如下关系：

board_init_r -> stdio_init -> drv_lcd_init -> lcd_init

另外在板子的初始化信息输出中可以看到：

```
** File not found logo.bmp **
can't find bmp at 0x47000000 (type:0xffff), fb:0x46000000...
LOGO: DRAW FB=0x46000000, X=   0, Y=   0, Bpp=0
can't find bmp at 0x47000000 (type:0xffff), fb:0x46000000...
LOGO: DRAW FB=0x46000000, X=1024, Y= 600, Bpp=32
RGB: display.0
MIPI: display.0
```

通过这句调试信息：“can't find bmp at”就找到了lcd_draw_boot_logo函数，根据该函数的调用情况，我们又可以层层向上找，发现了两个调用实现。

###### 通过命令显示bmp图片

drawbmp(命令) -> do_drawbmp -> lcd_draw_boot_logo

###### uboot启动过程中调用到

在执行汇编代码中的：ldr pc, =board_init_r时，会找函数指针数组init_sequence_r[]中的函数执行初始化

init_sequence_r[] -> board_late_init -> bd_display_run -> lcd_draw_boot_logo

###### 将bmp图片从mmc分区中拷贝到0x47000000

ext4load（命令）

do_ext4_load -> do_load -> fs_read -> info->read(filename, buf, offset, len) -> ext4_read_file

##### 分析

从调试信息中来看，在DDR3内存中，有一块区域地址为0x47000000，在这里存放一张bmp图片。一块区域地址为0x46000000，是显存，该块显存与Lcd屏幕绑定，会显示该显存中的内容。也就是说，若0x47000000中有一张图片，那么就会将其拿给0x46000000，并显示到屏幕上。

那么，现在需要做的就是将一张bmp图片，放到mmc卡中的某个区域，在启动时，将这张图片读取到DDR3的0x47000000中。

而经过前面的分析我们可以得知，能够通过ext4load命令将固化在mmc的一张bmp图片加载到DDR，再通过drawbmp命令实现将DDR上的bmp拷贝到显存（图片显示）。

整个源码分析过程中，依然只找到了命令相关的实现，没有找到其他的代码直接实现的情况。故应该是直接使用命令的方式来显示图片。

##### 实际情况

通过查找ext4load命令在哪里被调用到，找到以下调用路径：

```
ldr pc, =board_init_r
	-->init_sequence_r[]
		-->board_late_init
			-->bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
				-->#define CONFIG_CMD_LOGO_WALLPAPERS "ext4load mmc 2:1 0x47000000 logo.bmp; drawbmp 0x47000000"

```

所以只要将图片放到根文件目录下，并命名为logo.bmp就可以 完成任务

(mmc卡中的分区： 2:0表示的是存放uboot的区域 2:1表示的是kernel的区域 2:2表示的是根文件的区域)

## Kernel裁剪移植

### kernel简介

#### kernel是什么？

linux系统 && kernel（内核）

kernel其实是linux操作系统中后台运行的核心代码。我们可以将一个完整的linux系统划分为开放的系统前台（包括lib，tools，app，fs等）和相对封闭的系统后台（kernel）

### kernel配置编译操作

#### 工程包

```
root@bound-virtual-machine:/opt/kernel-build# ls
defconfig_v2.0_jason_17.11.28  make_ext4fs  mkuserimg.sh
kernel-3.4.39_cfg.tar.bz2      mkimage
```

##### 1. 准备工作

###### 1.1 安装工具链

/usr/local/arm/arm-eabi-xxx
如果准备好，则不管

###### 1.2 准备目录

​	#mkdir /opt/build_kernel
​	#cp kernel-3.4.39_cfg.tar.bz2 /opt/build_kernel

##### 2. 配置源码

#cd /opt/build_kernel
#tar xvfj kernel-3.4.39_cfg.tar.bz2
#cd kernel-3.4.39

​	#cp defconfig_v2.0_jason_17.11.28  .config 
​	#make menuconfig 

可以看到一个显示出一个菜单界面，什么都不用做，直接退出。

如果提示无法打开菜单界面，则执行
	#apt-get install ncurses-dev

##### 3. 编译出uImage

#make uImage -j3 ARCH=arm CROSS_COMPILE=/usr/local/arm/arm-eabi-4.8/bin/arm-eabi- 

编译完毕，会在arch/arm/boot目录下，生成了一个名为uImage的文件，这个就是内核的镜像文件。

在这里会出现问题，编译不成功，要将mkimage拷贝到bin目录下

如果是不打算烧写到eMMC卡，则可以通过改造后的fastboot下载到ddr3中直接执行
开发板重启后，进入uboot交互界面，执行：
fastboot 
使用windows下的fastboot下载 刚编出的那uImage
fastboot flash NULL uImage
开发板会显示下载完成的信息，按下ctrl+c强制退出死循环，再次进入交互界面
bootm 48000000 
可以看到kernel正常跑起来，这个就是你刚编译出来的那个uImage

如果想要烧写到eMMC卡，则需要利用工具转换成img格式，方法参考下面。

##### 4.转换成ext4文件

###### 4.1  安装依赖工具包

将make_ext4fs 、mkuserimg.sh三个文件拷贝到与kernel-3.4.39同级目录
#cp make_ext4fs  /opt/build_kernel
#cp mkuserimg.sh /opt/build_kernel

将mkimage拷贝到ubuntu下面的/bin即可。

###### 4.2 制作ext4文件

cd /opt/build_kernel/
mkdir out/
cp kernel-3.4.39/arch/arm/boot/uImage out/
./mkuserimg.sh -s out  out/boot.img ext4 boot 67108864

执行完毕，会在当前out目录下生成一个boot.img文件.

这时，会报如下错误：
bash: ./make_ext4fs: No such file or directory 

错误解决方法
因为make_ext4fs是32bit程序，所以需要安装32bit依赖包
#apt-get install lib32c-dev
#apt-get install lib32stdc++6

 再次烧写boot.img到开发板mmc 2:1区域
fastboot flash boot boot.img 

### kernel工程管理

#### kernel工程配置管理-kconfig文件集合

示例分析：make menuconfig

找到makefile可以看到：

```
%config: scripts_basic outputmakefile FORCE
        $(Q)mkdir -p include/linux include/config
        $(Q)$(MAKE) $(build)=scripts/kconfig $@

```

这里创建了三个依赖文件，再创建了两个目录，最后执行make语句

makefile中的build机制（scripts/Kbuild.include）：

```
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj
```

所以之前的config语句可以简化为：

```
make -f scripts/Makefile.build obj=scripts/kconfig menuconfig
```

所以可以看到这条语句，先要将scripts/kconfig作为变量传送到scripts/Makefile.build中去得到结果，再执行menuconfig

##### 第一步

scripts/Makefile.build obj=scripts/kconfig

找到scripts/Makefile.build文件，其中第一行：

```
src := $(obj)
```

这里就是把scripts/kconfig赋值给src

```
kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
include $(kbuild-file)
```

这里通过filter函数判断src中是否包含/，若包含，则直接返回src给到kbuild-dir，也就是相当于kbuild-dir = scripts/kconfig。

随后，通过wildcard函数判断了scripts/kconfig下是否存在Kbuild，这里不存在，则返回了scripts/kconfig/Makefile给到kbuild-file

最后将该路径返回

那么最后简化得到的命令语句就是：

```
make -f scripts/kconfig/Makefile menuconfig
```

##### 第二步

到scripts/kconfig/Makefile中去编译真正的menuconfig

```
menuconfig: $(obj)/mconf
        $< $(Kconfig)
```

所以配置过程中make menuconfig中真正的操作：

1. 创建 scripts/kconfig/mconf



2. 执行scripts/kconfig/mconf



### kernel启动源码包分析
